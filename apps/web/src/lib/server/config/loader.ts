import { readFileSync, writeFileSync, existsSync, mkdirSync } from "fs";
import { dirname } from "path";
import { parse as parseDotenv } from "dotenv";
import {
  type AppConfig,
  appConfigSchema,
  partialAppConfigSchema,
  getDefaultConfigPath,
  envMappings,
} from "./schema";

/**
 * Set a nested value in an object using a path array
 */
function setNestedValue(obj: Record<string, any>, path: string[], value: any): void {
  let current = obj;
  for (let i = 0; i < path.length - 1; i++) {
    if (!(path[i] in current)) {
      current[path[i]] = {};
    }
    current = current[path[i]];
  }
  current[path[path.length - 1]] = value;
}

/**
 * Load environment variables from config file using dotenv parser
 */
function loadEnvFile(configPath: string): Record<string, string> | null {
  if (!existsSync(configPath)) {
    return null;
  }

  try {
    const content = readFileSync(configPath, "utf-8");
    return parseDotenv(content);
  } catch (err) {
    console.warn(`Failed to load config file ${configPath}:`, err);
    return null;
  }
}

/**
 * Build raw config object from env vars using mappings
 * Values are kept as strings - Zod coercion will handle type conversion
 */
function buildConfigFromEnv(env: Record<string, string | undefined>): Record<string, any> {
  const config: Record<string, any> = {};

  for (const [envVar, mapping] of Object.entries(envMappings)) {
    const value = env[envVar];
    if (value !== undefined && value !== "") {
      setNestedValue(config, mapping.path, value);
    }
  }

  return config;
}

/**
 * Deep merge two objects (source overrides target)
 */
function deepMerge(target: Record<string, any>, source: Record<string, any>): Record<string, any> {
  const result = { ...target };

  for (const key of Object.keys(source)) {
    if (
      source[key] &&
      typeof source[key] === "object" &&
      !Array.isArray(source[key]) &&
      target[key] &&
      typeof target[key] === "object"
    ) {
      result[key] = deepMerge(target[key], source[key]);
    } else {
      result[key] = source[key];
    }
  }

  return result;
}

/**
 * Load and merge configuration from all sources
 * Priority: process env vars > config file > defaults (from Zod schema)
 * Validates and coerces with Zod schema
 */
export function loadConfig(env: Record<string, string | undefined> = process.env): AppConfig {
  // Build config from sources (values as strings, Zod will coerce)
  let rawConfig: Record<string, any> = {};

  // Determine config file path
  const configPath = env.FALLPAPER_CONFIG || getDefaultConfigPath();

  // Load config file
  const fileEnv = loadEnvFile(configPath);
  if (fileEnv) {
    console.log(`Loaded config from ${configPath}`);
    rawConfig = deepMerge(rawConfig, buildConfigFromEnv(fileEnv));
  }

  // Apply process environment variable overrides (higher priority)
  rawConfig = deepMerge(rawConfig, buildConfigFromEnv(env));

  // Parse with Zod - handles coercion and defaults for missing values
  const result = partialAppConfigSchema.safeParse(rawConfig);
  if (!result.success) {
    console.error("Invalid configuration:", result.error.flatten());
    throw new Error(`Invalid configuration: ${result.error.message}`);
  }

  return result.data;
}

/**
 * Get config file path that would be used
 */
export function getConfigPath(env: Record<string, string | undefined> = process.env): string {
  return env.FALLPAPER_CONFIG || getDefaultConfigPath(env);
}

/**
 * Check if config file exists
 */
export function configFileExists(env: Record<string, string | undefined> = process.env): boolean {
  return existsSync(getConfigPath(env));
}

/**
 * Get nested value from object using path array
 */
function getNestedValue(obj: Record<string, any>, path: string[]): any {
  let current = obj;
  for (const key of path) {
    if (current === undefined || current === null) {
      return undefined;
    }
    current = current[key];
  }
  return current;
}

/**
 * Generate .env file content from config
 */
export function generateEnvContent(config: AppConfig): string {
  const lines: string[] = [
    "# Fallpaper Configuration",
    "# Generated by Fallpaper Settings UI",
    "",
    "# Database",
  ];

  // Group by section
  const sections: Record<string, string[]> = {
    database: [],
    scheduler: [],
    runner: [],
  };

  for (const [envVar, mapping] of Object.entries(envMappings)) {
    const value = getNestedValue(config, mapping.path);
    if (value !== undefined) {
      const section = mapping.path[0];
      const formattedValue = typeof value === "string" && value.includes(" ")
        ? `"${value}"`
        : String(value);
      sections[section]?.push(`${envVar}=${formattedValue}`);
    }
  }

  // Database section
  lines.push(...sections.database);
  lines.push("", "# Scheduler");
  lines.push(...sections.scheduler);
  lines.push("", "# Runner");
  lines.push(...sections.runner);
  lines.push("");

  return lines.join("\n");
}

/**
 * Validate config with Zod schema
 * Returns validated config or throws error
 */
export function validateConfig(config: unknown): AppConfig {
  const result = appConfigSchema.safeParse(config);
  if (!result.success) {
    throw new Error(`Invalid configuration: ${result.error.message}`);
  }
  return result.data;
}

/**
 * Save config to file (validates before saving)
 */
export function saveConfig(
  config: AppConfig,
  configPath: string = getConfigPath()
): void {
  // Validate config before saving
  const validated = validateConfig(config);

  // Ensure directory exists
  const dir = dirname(configPath);
  mkdirSync(dir, { recursive: true });

  // Generate and write content
  const content = generateEnvContent(validated);
  writeFileSync(configPath, content, "utf-8");
}
